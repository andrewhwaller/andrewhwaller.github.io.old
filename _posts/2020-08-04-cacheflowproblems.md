---
layout: post
title: Cache Flow Problems
---
In previous Rails APIs that I've built, things have been pretty straightforward. Data is provided by the user, it gets persisted to the database through the API, and that data is virtually immediately available for use. However, in the process of testing my most recent Rails project, I noticed that the data being returned from my API didn't seem to be synced up with the data I was sending out from my client. I spent a good amount of time trying to solve this issue on the client side. I figured that somewhere along the way, my React frontend was sending out the wrong data or using old data that had been returned from the most recent call to my API's index route. But no matter how many breakpoints I dropped and no matter how many arguments I checked in my React actions, the data always seemed to come back stale. What was the issue? My first thought was to restart my Heroku deployment. I have this particular app deployed on one of Heroku's free tier dynos; perhaps the dyno was just running slowly and perhaps my Postgres database simply wasn't updating quickly enough to return the data immediately after it had been saved. I restarted the dyno and did some more testing, but the problem persisted. After much longer than I'd care to admit, I thought to check my API's serializer. I'm using FastJsonApi for this project, which is a fairly standard gem to use. In previous projects, I had implemented FastJsonApi with a fairly basic set up and everything had worked fine. So fine, in fact, that I hadn't really taken the time to properly look at my set up or thoroughly read the FastJsonApi docs. Big mistake! It turns out that I had left the cache options for the serializer on. This means that the serializer was actually storing the JSON it generated and reusing it for subsequent requests! Of course the data coming back was stale! After facepalming myself into oblivion, I changed the cache options and was greeting with fresh data as expected. In previous projects, I wasn't requesting data so soon after saving it, so this particular flaw in my set up didn't come up. Moral of the story: read the docs, understand your set up, and think through which options you're enabling and why.
